# 集合引用类型

## Object类型

创建Object实例的两种方式：`new Object()`和`{}`

函数传参时必选参数使用命名参数，再通过一个对象字面量来封装多个可选参数

对象的属性通过`.`语法来获取，也可以通过`["属性名"]`来获取

## Array类型

创建Array实例的两种方式：`new Array()`和`[]`

### Array静态方法

`Array.from()`将类数组结构转为数组结构。第一个参数是类数组对象（即可迭代的对象）或者有length属性和可检索元素的对象，第二个参数是一个可选的映射函数，第三个参数用于指定this值（箭头函数中不适用）

```js
const a1 = [1,2,3,4]
const a2 = Array.from(a1) // 数组浅拷贝

const arrayLikeObject = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    length: 4
}
console.log(Array.from(arrayLikeObject)) // [1,2,3,4]

const a3 = Array.from(a1,function(x){return x**this.exponent},{exponent: 2})
```

`Array.of()`将一组参数转化为数组，用于替代`ES6`之前的`Array.prototype.slice.call(arguments)`这种写法

```js
Array.of(1,2,3,4) // [1,2,3,4]
```

### 数组索引

数组可以通过索引获取数组的值，数组的长度length可修改数组长度

### 检测数组

在只有一个全局对象的情况下（即网页没有多个框架），用`instanceof`即可，如果有多个全局对象，则需要用`Array.isArray()`

### 迭代器方法

`keys()`返会数组索引的迭代器，`values()`返回数组元素的迭代器，`entries()`返回索引/值对的迭代器

```js
const a = ['foo','bar','baz','qux']
const aKeys = Array.from(a.keys()) // [0,1,2,3]
const aValues = Array.from(a.values()) // ['foo','bar','baz','qux']
const aEntries = Array.from(a.entries()) // [[0,'foo'],[1,'bar'],[2,'baz'],[3,'qux']]
```

### 复制和填充方法

`fill(填充字符，开始索引，结束索引)`向数组的开始索引至结束索引之间插入填充字符

`copyWithin(填充开始索引，开始复制索引，结束复制索引)`浅复制指定索引内的内容，然后填充到指定索引位置

### 转换方法

`toLocaleString()`

`toString()`返回数组每一项拼接而成的逗号分隔的字符串

`valueOf()`返回数组本身

`join(拼接参数)`将数组用参数分隔拼接成一个字符串

### 栈方法

`push()`接受任意数量参数添加到末尾，返回数组长度

`pop()`删除数组最后一项，返回被删除的项

### 队列方法

`unshift()`接受任意数量参数添加到开头，返回数组长度

`shift()`删除数组第一项，返回被删除的项

### 排序方法

`reverse()`将数组反转

`sort()`将数组每项调用`String()`进行排序，可接受一个比较函数

### 操作方法

`concat()`接受任意个参数，将其添加到源数组副本的后面，参数如果是数组，会自动打平，可以设置`Symbol.isConcatSpreadable`为false来禁止强制打平数组

```js
let colors = ['red','green','blue']
let colors2 = colors.concat('yellow',['black','brown'])
console.log(colors) // ['red','green','blue']
console.log(colors2) // ['red','green','blue','yellow','black','brown']

let moreNewColors = {
    [Symbol.isConcatSpreadable]: false
    length: 2,
    0: 'pink',
    1: 'cyan'
}
let colors3 = colors.concat(moreNewColors)
console.log(colors3) // ['red','green','blue',['pink','cyan']]
```

`slice(开始索引，结束索引)`将源数组的副本从开始索引开始截取，直到结束索引，返回截取的数组

`splice(开始索引，删除长度n，添加的值)`将原数组从开始索引位置开始删除，删除n个项，然后将后面的值插入给数组

### 搜索和位置方法

#### 严格相等

`indexOf(要查找的元素，开始查找的位置)`从头或者从参数二位置开始查找元素，找到返回索引，没找到返回-1

`lastIndexOf(要查找的元素，开始查找的位置)`从最后一项或者参数二位置开始往前查找元素，找到返回索引，没找到返回-1

`includes(要查找的元素，开始查找的位置)`从头或者参数二位置开始查找元素，找到返回true，没找到返回false

#### 断言函数

`find(断言函数)`数组每项调用断言函数，如果断言函数返回真值则表示匹配，返回匹配的项

`findIndex(断言函数)`数组每项调用断言函数，如果断言函数返回真值则表示匹配，返回匹配的项的索引

### 迭代方法

每个迭代方法接受两个参数：以每一项为参数运行的函数和函数this对象

`every()`对数组每一项都运行函数，如果每一项函数都返回true，则返回true

`some()`对数组每一项都运行函数，如果有一项函数都返回true，则返回true

`filter()`对数组每一项都运行函数，函数返回true的项组成数组后返回

`map()`对数组每一项都运行函数，返回由每次函数调用的结果构成的数组

`forEach()`对数组每一项都运行函数，没有返回值

### 归并方法

`reduce(归并函数，归并初始值)`从左往右迭代数组每一项，将上一次的结果作为下一次调用的初始值

`reduceRight(归并函数，归并初始值)`从右往左迭代数组每一项，将上一次的结果作为下一次调用的初始值

## 定型数组

### `ArrayBuffer`

`Float32Array`是一种视图，可以允许JavaScript运行时访问一块名为`ArrayBuffer`的预分配内存

`ArrayBuffer`是所有定型数组及视图引用的基本单位

`ArrayBuffer()`是一个构造函数，用于在内存中分配特定数量的字节空间

```js
const buf = new ArrayBuffer(16)
alert(buf.byteLength) // 16
```

`ArrayBuffer`一旦创建就不能再调整大小，可以通过`slice()`复制全部或者一部分到一个新实例中

```js
const buf1 = new ArrayBuffer(16)
const buf2 = buf1.slice(4,12)
alert(buf.byteLength)
```

> 要想读取`ArrayBuffer`，必须通过视图。

### `DateView`

这个视图专为文件I/O和网络I/O设计，其`API`支持对缓冲数据的高度控制，但性能比其他视图略差。`DateView`对缓冲内容没有任何预设，也不能迭代

必须在对已有`ArrayBuffer`读取或写入时才能创建`DataView`实例

```js
let buf = new ArrayBuffer(16)
const fullDateView = new DataView(buf)
alert(fullDateView.byteOffset)
alert(fullDateView.byteLength)
alert(fullDateView.buffer === buf)

const firstHalfDateView = new DataView(buf,0,8)
alert(firstHalfDateView.byteOffset)
alert(firstHalfDateView.byteLength)

const secondHalfDataView = new DataView(buf,8)
alert(secondHalfDataView.byteOffset)
alert(secondHalfDataView.byteLength)
```

通过`DataView`读取缓冲，需要几个组件：

1. 要读或写的字节偏移量
2. `DataView`应该使用`ElementType`来实现JavaScript的Number类型到缓冲内二进制格式的转换
3. 内存中值的字节序

#### `ElementType`

`DataView`对存储在缓冲内的数据类型没有预设。它暴露的`API`强制开发者在读、写时指定一个`ElementType`，然后`DataView`就会忠实的为读、写而完成相应的转换

| `ElementType` | 字节 | 说明               | 等价C类型        | 值的范围               |
| ------------- | ---- | ------------------ | ---------------- | ---------------------- |
| `Int8`        | 1    | 8位有符号整数      | `signed char`    | -128~127               |
| `Uint8`       | 1    | 8位无符号整数      | `unsigned char`  | 0~255                  |
| `Int16`       | 2    | 16位有符号整数     | `short`          | -32768~32767           |
| `Uint16`      | 2    | 16位无符号整数     | `unsigned short` | 0~65535                |
| `Int32`       | 4    | 32位有符号整数     | `int`            | -2147483628~2147483647 |
| `Uint32`      | 4    | 32位无符号整数     | `unsigned int`   | 0~4294967295           |
| `Float32`     | 4    | 32位IEEE-754浮点数 | `float`          | -3.4e+38~+3.4e+38      |
| `Float64`     | 8    | 64位IEEE-754浮点数 | `double`         | -1.7e+308~+1.7e+308    |

`DataView`为上表中的类型都暴露了get和set方法，这些方法使用`byteOffset`定位要读或写的值的位置

```js
const buf = new ArrayBuffer(2)
const view = new DataView(buf)

alert(view.getInt8(0))
alert(view.getInt8(1))
alert(view.getInt16(0))

view.setUint8(0,255) // 将整个缓冲区都设置为1，255的二进制位11111111
```

### 定型数组

创建定型数组的方式包括读取已有缓冲、使用自有缓冲、填充可迭代结构、填充基于任意类型的定型数组，通过`<ElementType>.from()`和`<ElementType>.of()`

```js
const buf = new ArrayBuffer(12);

// 读取已有缓冲
const ints = new Int32Array(buf)
alert(ints.length) // 3 因为类型时int，每个元素需要4字节，所以长度位3

// 使用自有缓冲
const ints2 = new Int32Array(6)
alert(inst2.length) // 6
alert(inst2.buffer.byteLength) // 24 因为类型是int，每个元素需要3字节，所以ArrayBuffer是24字节

// 填充可迭代结构
const ints3 = new Int32Array([2,4,6,8])
alert(ints3.length) // 4
alert(ints3.buffer.byteLength) // 16
alert(ints3[2]) // 6

// 填充任意类型的定性数组
const ints4 = new Int16Array(ints3)
alert(ints4.length) // 4
alert(ints4.buffer.byteLength) // 8

// 通过<ElementType>.from
const ints5 = Int16Array.from([1,2,3,4])
alert(ints5.length) // 4
alert(ints5.buffer.byteLength) // 8

// 通过<ElementType>.of
const floats = Float32Array.of(3.14,2.718,1.618)
alert(floats.length) // 3
alert(floats.buffer.byteLength) // 12
```

定型数组的构造函数和实例都有一个`BYTES_PER_ELEMENT`属性，返回定型数组每个元素的占用字节数

定型数组有`Symbol.iterator`属性，可通过`for...of`循环和扩展操作符来操作

#### 合并复制修改定型数组

定型数组使用数组缓冲来存储数据，数组缓冲是不能调整大小的，所以无法使用能改变数组大小的方法

`set(参数数组，指定位置)`从参数数组中把值复制到当前定型数组中指定的索引位置

```js
const container = new Int16Array(8)
container.set(Int8Array.of(1,2,3,4))
console.log(container) // [1,2,3,4,0,0,0,0]
container.set([5,6,7,8],4) 
console.log(container) // [1,2,3,4,5,6,7,8]
container.set([5,6,7,8],7) // RangeError
```

`subarray(开始复制位置，结束复制位置)`基于从原定型数组中复制的值返回一个新定型数组

```js
const source = Int16Array.of(2,4,6,8)
const fullCopy = source.subarray()
console.log(fullCopy) // [2,4,6,8]

const halfCopy = source.subarray(2)
console.log(halfCopy) // [6,8]

const partialCopy = source.subarray(1,3) // 从索引1复制到索引3
console.log(partialCopy) // [4,6]
```

定型数组模拟拼接

```js
// 第一个参数是应该返回的数组类型
// 其余参数是应该拼接在一起的定型数组
function typedArrayConcat(typedArrayConstructor,...typedArrays){
	// 计算所有数组中包含的元素总数
	const numElements = typedArrays.reduce((x,y)=>(x.length||x)+y.length)
	
	// 按照提供的类型创建一个数组，为所有元素留出空间
	const resultArray = new typedArrayConstructor(numElements)
	
	// 依次转移数组
	let currentOffset = 0
	typedArrays.map(x=>{
		resultArray.set(x,currentOffset)
		currentOffset += x.length
	})
	return resultArray
}
const concatArray = typedArrayConcat(Int32Array,Int8Array.of(1,2,3),Int16Array.of(4,5,6),Float32Array.of(7,8,9))
console.log(concatArray) // [1,2,3,4,5,6,7,8,9]
console.log(concatArray instanceof Int32Array) // true
```

#### 下溢和上溢

定型数组中值的下溢和上溢不会印象到其他索引

```
const ints = new Int8Array(2)
const unsignedInts = new Uint8Array(2)

unsignedInts[1] = 256
console.log(unsignedInts[1]) // [0,0]  只会取最低有效位上的8位
unsignedInts[1] = 511
console.log(unsignedInts[1]) // [0,255]
```

