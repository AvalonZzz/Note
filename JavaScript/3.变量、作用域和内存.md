# 变量、作用域和内存

## 原始值和引用值

> 保存原始值的变量是按值访问的
>
> 保存引用值的变量是按引用访问的

### 复制值

复制原始值会创建一个副本，并且把副本赋值给新的变量，两个变量**互不干扰**

引用值复制的时候,复制的其实是值的指针,此时两个变量的指针指向同一个内存地址,所以这两个变量是**互相映射的**

### 传递参数

`ECMAScript`的函数参数都是按值传递的,变量访问有按值访问和按引用访问之分

```js
function setName(obj){
	obj.name = "zzz";
}
let person = new Object();
setName(person)
console.log(person.name); // 'zzz',函数参数是按值传递的,所以obj的值是一个地址的复制值,但是修改和访问引用变量时是按引用访问的,所以修改后还是会映射到原有值
function setName(obj){
	obj.name = 'zzz'
	obj = new Object();
	obj.name = 'zcw'
}
let person = new Object();
setName(person)
console.log(person.name); // 'zzz',如果函数传参是按引用传递的,那么修改obj的值时,会映射到变量person的值,但实际没有影响,所以函数传参是按值传递的
```

### `instanceof`

此操作符会根据变量的原型链的类型来判断出结果

```js
person instanceof Object; // person变量是Object类型吗?
colors instanceof Array; // colors变量时Array类型吗?
```

## 执行上下文和作用域

每个上下文都有一个变量对象，上下文中定义的变量和函数都存在这个变量对象上

全局上下文是最外层的上下文,执行上下文在其所有代码都执行完毕后会被销毁

当代码执行流进入函数时,函数的上下文会被推到上下文栈中。函数执行完后,上下文栈将函数上下文弹出,控制权返还给之前的执行上下文

上下文中的代码执行的时候,会创建变量对象的作用于链(决定了各级上下文中的代码在访问变量和函数时的顺序)。函数上下文的活动对象(初始值只有arguments对象)作为其变量对象