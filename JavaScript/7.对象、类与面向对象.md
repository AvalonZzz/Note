# 对象、类

## 对象

### 属性类型

#### 数据属性

- `[[Configurable]]`是否可以用`delete`删除，是否可以修改属性特性，是否可以把它改为访问器属性，默认为true
- `[[Enumerable]]`是否可用`for-in`循环，定义在对象上的属性都为true
- `[[Writable]]`是否可修改属性值，定义在对象上的属性都为true
- `[[Value]]`包含属性实际的值

数据属性可通过`Object.defineProperty(对象，属性，描述符对象)`来修改特性

```js
let person = {}
Object.defineProperty(person,'name',{
	writable: false,
	value: 'zzz'
})
console.log(person.name) // 'zzz'
person.name = 'll'
console.log(person.name) // 'zzz'
```

`Object.defineProperty()`可多次调用，但一个属性的`[[Configurable]]`一旦设置为false就不能再修改非`[[Writable]]`属性了

调用`Object.defineProperty()`时，如果不指定`[[Configurable]]、[[Enumerable]]、[[Writable]]`则默认为false

#### 访问器属性

- `[[Configurable]]`是否可以用`delete`删除，是否可以修改属性特性，是否可以把它改为访问器属性，默认为true
- `[[Enumerable]]`是否可用`for-in`循环，定义在对象上的属性都为true
- `[[Get]]`在读取属性时调用
- `[[Set]]`在写入属性时调用

```js
let book = {
	year_: 2017,
	edition: 1
}
Object.defineProperty(book,'year',{
	get(){
		return this.year_;
	},
	set(){
		if(newValue > 2017){
			this.year_ = newValue
			this.edition += newValue = 2017
		}
	}
})

book.year = 2018
console.log(book.edition) // 2
```

### 定义多个属性

`Object.defineProperties()`可一次性定义多个属性的描述符

```js
let book = {}
Object.definedProperties(book,{
    year_: {
        value: 2007
    },
    edition: {
        value: 1
    },
    year: {
        get(){
            return this.year_
        },
        set(){
            if(newValue > 2017){
                this.year_ = newValue
                this.edition += newValue - 2017
            }
        }
    }
})
```

### 读取属性特性

`Object.getOwnPropertyDescriptor(对象，属性)`获取属性的描述符

`Object.getOwnpropertyDescriptors(对象)`获取对象所有属性的描述符(es2017新增)

```js
let book = {}
Object.defineProperties(book,{
    year_: {
        value: 2017
    },
    edition: {
        value: 1
    }
})
let descriptor = Object.getOwnPropertyDescriptor(book,"year_")
let descriptors = Object.getOwnPropertyDescriptors(book)
```

### 对象标识及相等判断

`Object.is(参数一，参数二)`用于判断参数一和参数二是否相等

### 对象解构

对象结构就是用与对象匹配的结构来实现属性赋值

```js
let person = {
	name: 'zzz',
	age: 27
}
let {name,age} = person // 普通解构
let {name: personName,age: personAge} = person // 重命名解构
let {name, job} = person // 不完全解构
let {name, job="software engineer"} = person // 解构默认值
```

#### 解构赋值嵌套

```js
let person = {
	name: 'zzz',
	age: 27,
	job: {
		title: 'software engineer'
	}
}
let {job: {title}} = person
console.log(title) // 'zzz'
// 外层属性没有定义的情况下不能使用嵌套解构
({foo: {bar: personCopy.bar}} = person) // TypeError 
```

#### 部分解构

解构表达式开始的解构赋值成功后面的赋值错误，则整个解构赋值只会完成一部分

```js
let person = {
	name: 'zzz',
	age: 27
}
let personName,personAge,personJob;
try{
	({name: personName,foo: {age: personAge,bar: personJob}}) = person // 只会完成部分解构
}
```

#### 参数上下文匹配

对参数解构赋值不会影响`arguments`对象

```js
let person = {
	name: 'zzz',
	age： 27
}

function printPerson(foo,{name,age},bar){
	console.log(arguments)
	console.log(name,age)
}

function printPerson2(foo,{name: personName,age: personAge},bar){
	console.log(arguments)
	console.log(personName,personAge)
}

printPerson('1st',person,'2nd') 
// ['1st',{name: 'zzz',age: 27},'2nd']
// 'zzz', 27

printPerson2('1st',person,'2nd')
// ['1st',{name: 'zzz',age: 27},'2nd']
// 'zzz', 27
```

## 创建对象

### 工厂模式

```js
function createPerson(name,age,job){
	let o = new Object;
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function(){
		console.log(this.name)
	}
	return o
}
let person1 = createPerson('zzz',27,'software engineer')
let person2 = createPerson('ll',27,'doctor')
```

这样调用几次函数就能创建几个具有相同属性的对象

### 构造函数模式

自定义构造函数可以确保实例被标识为特定类型

```js
function Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = function(){
		console.log(this.name)
	}
}
let person1 = new Person('zzz',27,'software engineer')
let person2 = new Person('ll',27,'doctor')
person1.sayName() // 'zzz'
person2.sayName() // 'll'
```

构造函数和工厂模式的区别：

- 没有显示创建对象
- 属性和方法赋值给this
- 没有return

**new操作符调用构造函数会执行以下操作**

- 在内存中创建一个新对象
- 这个新对象内部的`[[prototype]]`特性被赋值为构造函数的`prototype`属性
- 构造函数内部的this被赋值为这个对象
- 执行构造函数内部的代码
- 如果构造函数返回非空对象，则返回该对象，否则返回刚创建的对象

构造函数的问题是**会在每个实例上把属性和方法都创建一遍，会造成重复**

```js
person1.sayName === person2.sayName // false
// 解决方法：将公用方法抽取出来
function Person(name,age,job){
	this.name = name
	this.age = age
	this.job = job
	this.sayName = sayName
}
function sayName(){
	console.log(this.name)
}
```

### 原型模式

每个函数都有`prototype`属性，包含实例共享的属性和方法。这个对象就是调用new操作符创建的对象的原型

#### 理解原型

只要创建一个函数，就会为这个函数创建一个`prototype`属性（指向原型对象）。并在原型对象中创建一个指回构造函数的`constructor`属性，创建的对象实例的`[[Prototype]]`指针会被赋值为构造函数的原型对象，`[[Prototype]]`即`__proto__`

```js
function Person(){}
console.log(Person.prototype)//{constructor: ƒ Person(),__proto__: Object}
console.log(Person.prototype.constructor === Person) // true
console.log(Person.prototype.__proto__ === Object.prototype) // true
console.log(Person.prototype.__proto__.constructor === Object) // true
console.log(Person.prototype.__proto__) 
// {
//   constructor: f Object(),
//   toString: ...
//   hasOwnProperty: ...
//   isPrototypeOf: ...
//   ...
// } 
let person1 = new Person()
let person2 = new Person()
console.log(person1.__proto__ === Person.prototype) // true
console.log(person1.__proto__ === person2.__proto__) // true
```

![原型](/Users/avalon/Documents/Note/imgs/原型.svg)

![原型](C:\Users\Administrator\Desktop\Note\imgs\原型.svg)

`Object.getPrototypeOf(对象)`获取传入对象的原型对象，作用和`__proto__`一样

`Object.setPrototypeOf(对象)`将对象的原型重新赋值，即重写继承关系，因为会影响所有使用了这个原型对象的代码，所以性能差

#### 原型层级

访问对象属性时，先在对象上查找，没有则找原型对象，如果实例和原型对象上有同名属性，则取实例上的属性值

#### `in`操作符

`in`操作符会在可以通过对象访问指定属性时返回true，无论属性是在实例上还是原型上

`for-in`操作符可以通过对象访问且可以被枚举的属性都会返回，包括实例和原型

`Object.keys(对象)`获取对象上所有可枚举的实例属性

`Object.getOwnPropertyNames()`获取所有实例属性，无论是否可枚举

`Object.getOwnPropertySymbols()`获取所有实例Symbol属性

#### 属性枚举顺序

`Object.keys()`和`for-in`枚举顺序不确定

`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`和`Object.assign()`枚举顺序是确定的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键

### 对象迭代

静态方法`Object.values()`和`Object.entries()`返回内容的数组和键值对的数组，非字符串属性会转换为字符串输出，这两个方法执行的是浅复制，符号属性会被忽略

#### 修改原型对象

```js
function Person(){}
Person.prototype = {
    name: 'zzz',
    age: 27,
    job: 'software engineer',
    sayName(){
        console.log(this.name)
    }
}
```

像上面那样修改原型对象后，`constructor`就不再指向Person了，而是指向Object了，可以重新设定`constructor`

```js
Person.prototype = {
	constructor: Person，
    name: 'zzz',
    age: 27,
    job: 'software engineer',
    sayName(){
        console.log(this.name)
    }
}
// 上面那样指定了之后constructor的[[Enumerable]]就为true了，可修改为下面那样
Person.prototype = {
    name: 'zzz',
    age: 27,
    job: 'software engineer',
    sayName(){
        console.log(this.name)
    }
}
Object.defineProperty(Person.prototype,'constructor',{
    enumerable: false,
    value: Person
})
```

#### 原型的动态性

从原型上搜索值的过程是动态的，即使实例在修改原型前已经存在，改动原型对象就会在实例上反映出来

```js
let friend = new Person()
Person.prototype.sayHi = function(){
    console.log('hi')
}
friend.sayHi() // 'hi'
```

实例的`[[prototype]]`指针是在调用构造函数时自动赋值的，即使原型重新赋值为新的对象，实例的`[[prototype]]`还是指向最初的原型，重写整个原型只是切断构造函数和原型之间的联系

```js
function Person(){}
let friend = new Person()
Person.prototype = {
  constructor: Person,
  name: 'zzz',
  age: 27,
  job: 'software engineer',
  sayName(){
    console.log(this.name)
  }
}
friend.sayName() // 报错，实例的[[prototype]]指向的对象上没有sayName方法
```

![原型的动态性](/Users/avalon/Documents/Note/imgs/原型的动态性.png)

***重写原型之后创建的实例才会引用新的实例***

#### 原生对象的原型

所有原生类型的构造函数都在原型上定义了实例方法，可通过`类型.prototype.xxx`来调用或者修改方法

```js
String.prototype.startsWith = function(text){
	return this.indexOf(text) === 0
}
let msg = "Hello World"
console.log(msg.startsWith("hello")) // true
```

#### 原型的问题

- 弱化向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值
- 原型上所有属性在实例间时共享的

