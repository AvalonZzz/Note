# 对象、类

## 对象

### 属性类型

#### 数据属性

- `[[Configurable]]`是否可以用`delete`删除，是否可以修改属性特性，是否可以把它改为访问器属性，默认为true
- `[[Enumerable]]`是否可用`for-in`循环，定义在对象上的属性都为true
- `[[Writable]]`是否可修改属性值，定义在对象上的属性都为true
- `[[Value]]`包含属性实际的值

数据属性可通过`Object.defineProperty(对象，属性，描述符对象)`来修改特性

```js
let person = {}
Object.defineProperty(person,'name',{
	writable: false,
	value: 'zzz'
})
console.log(person.name) // 'zzz'
person.name = 'll'
console.log(person.name) // 'zzz'
```

`Object.defineProperty()`可多次调用，但一个属性的`[[Configurable]]`一旦设置为false就不能再修改非`[[Writable]]`属性了

调用`Object.defineProperty()`时，如果不指定`[[Configurable]]、[[Enumerable]]、[[Writable]]`则默认为false

#### 访问器属性

- `[[Configurable]]`是否可以用`delete`删除，是否可以修改属性特性，是否可以把它改为访问器属性，默认为true
- `[[Enumerable]]`是否可用`for-in`循环，定义在对象上的属性都为true
- `[[Get]]`在读取属性时调用
- `[[Set]]`在写入属性时调用

```js
let book = {
	year_: 2017,
	edition: 1
}
Object.defineProperty(book,'year',{
	get(){
		return this.year_;
	},
	set(){
		if(newValue > 2017){
			this.year_ = newValue
			this.edition += newValue = 2017
		}
	}
})

book.year = 2018
console.log(book.edition) // 2
```

### 定义多个属性

`Object.defineProperties()`可一次性定义多个属性的描述符

```js
let book = {}
Object.definedProperties(book,{
    year_: {
        value: 2007
    },
    edition: {
        value: 1
    },
    year: {
        get(){
            return this.year_
        },
        set(){
            if(newValue > 2017){
                this.year_ = newValue
                this.edition += newValue - 2017
            }
        }
    }
})
```

### 读取属性特性

`Object.getOwnPropertyDescriptor(对象，属性)`获取属性的描述符

`Object.getOwnpropertyDescriptors(对象)`获取对象所有属性的描述符(es2017新增)

```js
let book = {}
Object.defineProperties(book,{
    year_: {
        value: 2017
    },
    edition: {
        value: 1
    }
})
let descriptor = Object.getOwnPropertyDescriptor(book,"year_")
let descriptors = Object.getOwnPropertyDescriptors(book)
```

### 对象标识及相等判断

`Object.is(参数一，参数二)`用于判断参数一和参数二是否相等

### 对象解构

对象结构就是用与对象匹配的结构来实现属性赋值

```js
let person = {
	name: 'zzz',
	age: 27
}
let {name,age} = person // 普通解构
let {name: personName,age: personAge} = person // 重命名解构
let {name, job} = person // 不完全解构
let {name, job="software engineer"} = person // 解构默认值
```

#### 解构赋值嵌套

```js
let person = {
	name: 'zzz',
	age: 27,
	job: {
		title: 'software engineer'
	}
}
let {job: {title}} = person
console.log(title) // 'zzz'
// 外层属性没有定义的情况下不能使用嵌套解构
({foo: {bar: personCopy.bar}} = person) // TypeError 
```

#### 部分解构

解构表达式开始的解构赋值成功后面的赋值错误，则整个解构赋值只会完成一部分

```js
let person = {
	name: 'zzz',
	age: 27
}
let personName,personAge,personJob;
try{
	({name: personName,foo: {age: personAge,bar: personJob}}) = person // 只会完成部分解构
}
```

#### 参数上下文匹配

对参数解构赋值不会影响`arguments`对象

```js
let person = {
	name: 'zzz',
	age： 27
}

function printPerson(foo,{name,age},bar){
	console.log(arguments)
	console.log(name,age)
}

function printPerson2(foo,{name: personName,age: personAge},bar){
	console.log(arguments)
	console.log(personName,personAge)
}

printPerson('1st',person,'2nd') 
// ['1st',{name: 'zzz',age: 27},'2nd']
// 'zzz', 27

printPerson2('1st',person,'2nd')
// ['1st',{name: 'zzz',age: 27},'2nd']
// 'zzz', 27
```

## 创建对象

### 工厂模式

```js
function createPerson(name,age,job){
	let o = new Object;
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function(){
		console.log(this.name)
	}
	return o
}
let person1 = createPerson('zzz',27,'software engineer')
let person2 = createPerson('ll',27,'doctor')
```

这样调用几次函数就能创建几个具有相同属性的对象

### 构造函数模式

自定义构造函数可以确保实例被标识为特定类型

```js
function Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = function(){
		console.log(this.name)
	}
}
let person1 = new Person('zzz',27,'software engineer')
let person2 = new Person('ll',27,'doctor')
person1.sayName() // 'zzz'
person2.sayName() // 'll'
```

构造函数和工厂模式的区别：

- 没有显示创建对象
- 属性和方法赋值给this
- 没有return

**new操作符调用构造函数会执行以下操作**

- 在内存中创建一个新对象
- 这个新对象内部的`[[prototype]]`特性被赋值为构造函数的`prototype`属性
- 构造函数内部的this被赋值为这个对象
- 执行构造函数内部的代码
- 如果构造函数返回非空对象，则返回该对象，否则返回刚创建的对象

构造函数的问题是**会在每个实例上把属性和方法都创建一遍，会造成重复**

```js
person1.sayName === person2.sayName // false
// 解决方法：将公用方法抽取出来
function Person(name,age,job){
	this.name = name
	this.age = age
	this.job = job
	this.sayName = sayName
}
function sayName(){
	console.log(this.name)
}
```

### 原型模式

