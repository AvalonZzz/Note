# 事件

## 事件流

当你点击一个按钮时，不光点击了这个按钮，还点击了它的容器及整个页面

### 事件冒泡

事件冒泡：事件从最具体的元素开始触发，向上传播至没有那么具体的元素

```html
<!DOCTYPE html>
<html>
<head>
  <title>Event Bubbling Example</title>
</head>
<body>
  <div id="myDiv">Click Me</div>
</body>
</html>
<!--div -> body -> html -> document-->
```

事件从DOM树一路向上依次触发

### 事件捕获

最不具体的节点最先收到事件，最具体的节点最后收到事件

### DOM事件流

`DOM2 Events`规范规定事件分为3个阶段：事件捕获、到达目标和事件冒泡

![](C:\Users\Administrator\Desktop\Note\imgs\事件流.png)

现在浏览器都支持DOM事件流

## 事件处理程序

### HTML事件处理程序

在HTML中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本

### `DOM`0级事件处理程序

把一个函数赋值给DOM对象的事件处理程序属性，所有元素（包括window和document）都有事件处理程序属性

所赋函数被视为元素的方法，因此事件处理程序会在元素的作用域中运行，即this等于元素

```js
let btn = document.getElementById('myBtn')
btn.onclick = function(){
	console.log(this.id) // 'myBtn'
}
```

`DOM`0级事件处理程序是注册在事件流的冒泡阶段的

通过将事件处理程序的值设为null，可以移除通过`DOM`0级添加的事件处理程序

```js
btn.onclick = null
```

### `DOM`2级事件处理程序

`addEventListener()`和`removeEventListener()`接收3个参数：事件名，事件处理程序和表在捕获阶段调用true还是冒泡阶段调用false

这两个函数暴露在所有DOM节点上

this等于元素

`DOM`2级的主要优势是可以为同一个事件添加多个事件处理程序

```js
let btn = document.getElementById('myBtn')
btn.addEventListener('click',()=>{
	console.log(this.id)
},false)
btn.addEventListener('click',()=>{
    console.log('hello world')
},false)
```

通过`addEventListener()`添加的事件处理程序只能通过`removeEventListener()`传入同样的参数来移除

```js
let btn = document.getElementById('myBtn')
btn.addEventListener('click',()=>{
	console.log(this.id)
},false)

btn.removeEventListener('click',()=>{
	console.log(this.id)
},false) // 没有效果，因为处理程序不是同一个实例，需要将处理程序提取出来注册

// 正确方式
let handler = function(){
	console.log(this.id)
}
btn.addEventListener('click',handler,false)
btn.removeEventListener('click',handler,false) // 有效果
```

### IE事件处理程序

`attachEvent()`和`detachEvent()`接收两个参数：事件名(要加'on')和事件处理函数

使用`attachEvent()`添加的事件处理程序会添加到冒泡阶段

`attachEvent()`是在全局作用域中运行的，所有this等于window

`attachEvent()`和`addEventListener()`一样可以为一个事件注册多个处理程序

```js
var btn = document.getElementById('myBtn')
btn.attachEvent('onclick',function(){
	console.log(this===window) // true
})
```

通过`attachEvent()`注册的事件处理程序只能通过`detachEvent()`传入相同参数来移除，两个方法的事件函数的引用要相同

```js
let btn = document.getElementById('myBtn')
let handler = function(){
	console.log('Clicked')
}

btn.attachEvent('onclick',handler)
btn,detachEvent('onclick',handler)
```

### 跨浏览器事件处理程序

```js
 let EventUtil = {
    addHandler(element,type,handler){
        if(element.addEventListener){
            element.addEventListener(type,handler,false)
        }else if(element.attachEvent){
            element.attachEvent('on'+type,handler)
        }else{
            element['on'+type] = handler
        }
    },

    removeHandler(element,type,handler){
        if(element.removeEventListener){
            element.removeEventListener(type,handler,false)
        }else if(element.detachEvent){
            element.detachEvent('on'+type,handler)
        }else{
            element['on'+type] = null
        }
    }
}
```

## 事件对象

### DOM事件对象

`event`对象是传给事件处理程序的唯一参数（不管是`DOM0`或`DOM2`还是HTML事件处理）

```js
btn.onclick = function(event) {
  console.log(event.type);  // "click"
};

btn.addEventListener("click", (event) => {
  console.log(event.type);  // "click"
}, false);

<input type="button" value="Click Me" onclick="console.log(event.type)">
```

**事件对象的公共属性和方法（全部都是只读）**

| 属性/方法                    | 类型           | 说明                                                         |
| ---------------------------- | -------------- | ------------------------------------------------------------ |
| `bubbles`                    | 布尔值         | 表示事件是否冒泡                                             |
| `cancelable`                 | 布尔值         | 表示是否可以取消事件默认行为                                 |
| `currentTarget`              | 元素           | 当前事件处理程序所在的元素                                   |
| `defaultPrevented`           | 布尔值         | true表示已经调用过`preventDefault()`方法                     |
| `detail`                     | 整数           | 事件相关的其他信息                                           |
| `eventPhase`                 | 整数           | 表示调用事件处理程序的阶段：1捕获，2目标，3冒泡              |
| `preventDefault()`           | 函数           | 用于取消事件的默认行为，只有`cancelable`为true才可以调用这个方法 |
| `stopImmediatePropagation()` | 函数           | 用于取消所有后续事件捕获或冒泡，并阻止调用任何后续事件处理程序 |
| `stopPropagation()`          | 函数           | 用于取消所有后续事件捕获或冒泡，只有bubbles为true才可以取消  |
| `target`                     | 元素           | 事件目标                                                     |
| `trusted`                    | 布尔值         | 表示事件是由浏览器生成的，false表示事件是由开发者通过`js`创建的 |
| `type`                       | 字符串         | 被触发的事件类型                                             |
| `view`                       | `AbstractView` | 与事件相关的抽象视图。等于事件所发生的window对象             |

在事件处理程序内部，`currentTarget`始终等于this，`target`则指向实际触发事件的目标

type属性可用于一个处理函数处理多个事件

```js
let handler = function(event){
	switch(event.type){
		case 'click':
			console.log('Clicked')
			break
		case 'mouseover':
			event.target.style.backgroundColor = 'red'
			break
		case 'mouseout':
			event.target.style.backgroundColor = ''
			break
	}
}
btn.onclick = handler
btn.onmouseover = handler
btn.onmouseout = handler
```

### IE事件对象

IE事件对象基于事件处理程序被指定的方式以不同方式来访问：`DOM0`方式指定，则event对象只是window对象的属性；如果用`attachEvent()`指定，则event对象会作为唯一参数传给处理函数

```js
var btn = document.getElementById("myBtn");
btn.onclick = function() {
  let event = window.event;
  console.log(event.type);  // "click"
};

var btn = document.getElementById("myBtn");
btn.attachEvent("onclick", function(event) {
  console.log(event.type);  // "click"
});
```

**IE事件对象的公共属性和方法**

| 属性/方法      | 类型   | 读写 | 说明                                    |
| -------------- | ------ | ---- | --------------------------------------- |
| `cancelBubble` | 布尔值 | 读写 | 默认为false，设置为true取消冒泡         |
| `returnValue`  | 布尔值 | 读写 | 默认为true，设置为false取消事件默认行为 |
| `srcElement`   | 元素   | 只读 | 事件目标（与target属性相同）            |
| `type`         | 字符串 | 只读 | 触发的事件类型                          |

IE事件处理程序的this取决于作用域，因此this并不总是等于事件目标，所以用`srcElement`代替this

```js
var btn = document.getElementById("myBtn");
btn.onclick = function() {
  console.log(window.event.srcElement === this);  // true
};

btn.attachEvent("onclick", function(event) {
  console.log(event.srcElement === this);         // false
});
```

### 跨浏览器事件对象

```js
let EventUtil = {
	getEvent(event){
        // 在DOM合规的浏览器中，event参数直接返回，在IE中，event没有定义，因此返回window.event
		return event ? event : window.event
	},
	
	getTarget(event){
		return event.target || event.srcElement
	},
	
	preventDefault(event){
		if(event.preventDefault){
			event.preventDefault()
		}else{
			event.returnValue = false
		}
	},
	
	stopPropagation(event){
		if(event.stopPropagation){
			event.stopPropagation()
		}else{
			event.cancelBubble = true
		}
	}
}
```

```js
let btn = document.getElementById("myBtn");
btn.onclick = function(event) {
  console.log("Clicked");
  event = EventUtil.getEvent(event);
  EventUtil.stopPropagation(event);
};

document.body.onclick = function(event) {
  console.log("Body clicked");
};
```

## 事件类型

分类：

- 用户界面事件
- 焦点事件
- 鼠标事件
- 滚轮事件
- 输入事件
- 键盘事件
- 合成事件

### 用户界面事件

