# DOM

## 节点层次

document节点是每个文档的根节点，在html中，根节点的唯一子节点是html元素

### Node类型

共有12中Node类型，可通过节点的`nodeType`属性访问，值为以下常量

1. `Node.ELEMENT_NODE`
2. `Node.ATTRIBUTE_NODE`
3. `Node.TEXT_NODE`
4. `Node.CDATA_SECTION_NODE`
5. `Node.ENTITY_REFERENCE_NODE`
6. `Node.ENTITY_NODE`
7. `Node.PROCESSING_INSTRUCTION_NODE`
8. `Node.COMMENT_NODE`
9. `Node.DOCUMENT_NODE`
10. `Node.DOCUMENT_TYPE_NODE`
11. `Node.DOCUMENT_FRAGMENT_NODE`
12. `Node.NOTATION_NODE`

#### nodeName和nodeValue

nodeName保存着节点的名字，对元素而言，nodeName始终是元素的标签名，nodeValue始终是null

#### 节点关系

每个节点都有一个childNodes属性，包含一个NodeList类数组实例，DOM结构变化会实时在NodeList中反映出来，可通过[]或item()来获取NodeList中的项

```js
let firstChild = article.childNodes[0]
let secondChild = article.childNodes.item(1)
let count = article.childNodes.length
```

每个节点都有一个parentNode属性，指向其DOM树中的父元素

childNodes中每个节点都是同一列表中其他节点的同胞节点，可通过previousSibling和nextSibling来访问，列表第一个节点的previousSibling和最后一个节点的nextSibling值为null

firstChild即childNodes[0]，lastChild即childNodes[childNodes.length-1]

hasChildNodes()方法用来检查节点是否有子节点，若结果为true则表示有一个或多个子节点

```js
article.hasChildNodes() // true
```

#### 操纵节点(通过parentNode操纵子节点)

appendChild(node)用于在childNodes列表末尾添加节点，返回值为新添加的节点的引用，如果传入的node在文档中已存在，则将该node移动到最后一个位置

insertBefore(要插入的节点，参照节点)，调用后要插入的节点变成参照节点的前一个同胞节点并返回。如果参照节点是null，则效果和appendChild一样

replaceChild(要插入的节点，要替换的节点)

removeChild(要删除的节点),返回被移除的节点

#### 其他方法

所有节点类型还共享了以下方法:

`cloneNode(布尔值)`会返回调用此方法的节点一模一样的节点，参数传入true表示深复制（即复制节点及其整个子DOM树），传入false只返回调用方法的节点，此时没有父节点，可用以上操作方法插入到文档中

### Document类型

Document类型是文档节点类型。document对象是HTMLDocument（继承自Document）的实例

Document类型的节点特征：

- nodeType为9
- nodeName值为'#document'
- nodeValue值为null
- parentNode值为null
- ownerDocument值为null
- 子节点可以是DocumentType，Element，ProcessingInstruction或Comment类型

#### 文档子节点

DOM提供了两个访问Document节点的子节点的快捷方式：

1. documentElement属性，始终指向html元素
2. body属性，指向body元素

Document类型的另一种可能的子节点是DocumentType。`<!doctype>`在文档中是独立的部分，可通过`document.doctype`来访问

#### 文档信息

`document.title`包含title元素中的文本

`document.URL`获取完整的URL

`document.domain`获取页面域名

`document.referrer`包含链接到当前页面的URL，如果页面没有来源，则返回空字符串

#### 定位元素

`getElementById(id值)`通过ID获取元素

`getElementsByTagName(标签名)`通过标签名获取有该标签名的`HTMLCollection`（和NodeList相似）

`HTMLCollection`有一个`namedItem()`方法，返回该`HTMLCollection`中有该name属性的元素

`getElementsByName(name值)`返回具有给定`name`属性的所有元素的`HTMLCollection`

#### 特殊集合

document对象上还暴露了几个特殊集合，也都是`HTMLCollection`实例

1. document.anchors：包含文档中所有带name属性的a标签
2. document.links：包含文档中所有带href的a标签
3. document.forms：包含文档中所有form元素
4. document.images：包含文档中所有img元素

### Element类型

`Element`表示XML或HTML元素，对外暴露出访问元素标签名、子节点和属性的能力

`Element`类型节点的特点：

- `nodeType`等于1
- `nodeName`值为元素的标签名
- `nodeValue`值为null
- `parentNode`值为`Document`或`Element`对象

可通过`nodeName`获取`tagName`来获取元素的标签名，返回值是大写的标签名，可用`toLowerCase()`来转为小写

#### HTML元素

所有元素都通过`HTMLElement`类型表示，`HTMLElement`继承自`Element`，每个HTML都有以下属性

- id：元素在文档中的唯一标识符
- title：包含元素的额外信息
- lang：元素内容的语言代码
- dir：语言的书写方向
- className：css的class类名

#### 获取属性

getAttribute('属性名')：获取HTML上的属性值

自定义属性根据规范以`data-`开头，公认（非自定义）属性都可通过DOM元素对象的属性取得，自定义属性不会成为DOM对象的属性

通过DOM对象访问的属性中有两个和`getArrtibute()`取得的值不同：

1. style属性：通过`getAttribute()`取得的style属性值是css字符串，通过DOM对象属性访问style返回的是一个CSSStyleDeclaration对象
2. 事件处理程序（如onclick)：通过`getAttribute()`取得的值是字符串形式的代码，通过DOM对象的属性访问事件属性返回的是js函数

#### 设置属性

setAttribute(要设置的属性名，属性值)：设置属性值，如果属性名已存在则是修改属性值

元素属性也是DOM属性，可以直接给DOM对象的属性赋值来设置元素属性值

```js
div.id = 'someID'
div.align = 'left'
```

自定义属性不会变成元素的属性，需要通过`setAttribute()`来设置

removeAttribute(属性名)：删除元素上的属性，不仅仅删除属性值，是将整个属性从元素上删除

#### attributes属性

`attributes`属性包含一个`NamedNodeMap`实例（类似NodeList的实时集合）。元素的每个属性表示为一个`Attr`节点，保存在这个`NamedNodeMap`对象中。

`NamedNodeMap`方法：

- `getNamedItem(name)`返回nodeName属性等于name的节点
- `removeNamedItem(name)`删除nodeName属性等于name的节点
- `setNamedItem(node)`向列表中添加node节点，以其nodeName为索引
- `item(pos)`返回索引pos处的节点

```js
let class = article.attributes.getNamedItem('class') //class="markdown-body"

let oldId = article.attributes.removeNamedItem('id') // id="article"

let a = document.createAttribute("my_attrib");
a.value = "newVal";
article.attributes.setNamedItem(a)
article.attributes.getNamedItem('my_attrib') // my_attrib="newVal"
```

#### 创建元素

`docucemnt.createElement(要创建的标签名)`用来创建新的元素

#### 元素后代

元素可以拥有任意多个子元素和后代元素。这些子元素和后代元素可通过`childNodes`属性全部获取到

### Text类型

Text类型的节点特征：

- `nodeType`为3
- `nodeName`为`"#text"`
- `nodeValue`为节点中包含的文本
- `parentNode`为`Element`对象
- 不支持子节点

`Text`节点的文本可以通过`nodeValue`和`data`属性访问和修改

文本节点操作文本的方法：

- `appendData(text)`向节点末尾添加文本text
- `deleteData(offset,count)`从位置offset开始删除count个字符
- `insertData(offset,text)`在位置offset插入text
- `replaceData(offset,count,text)`用text替换从位置offset到offset+count的文本
- `splitText(offset)`在位置offset将当前文本节点拆分为两个文本节点
- `substringData(offset,count)`提取从位置offset到offset+count的文本

#### 创建文本节点

`document.createTextNode(要插入节点的文本)`

#### 规范化文本节点

DOM文档中经常出现两个相邻文本节点，此时在两个文本节点的父节点上用`normalize()`方法将两个文本节点合并为一个，新的文本节点的nodeValue等于之前所有同胞文本节点nodeValue拼接在一起得到的字符串

```js
let element = document.createElement("div");
element.className = "message";

let textNode = document.createTextNode("Hello world!");
element.appendChild(textNode);

let anotherTextNode = document.createTextNode("Yippee!");
element.appendChild(anotherTextNode);

document.body.appendChild(element);

alert(element.childNodes.length);    // 2

element.normalize();
alert(element.childNodes.length);    // 1
alert(element.firstChild.nodeValue); // "Hello world!Yippee!"
```

### Comment类型

DOM中的注释通过Comment类型表示。Comment类型具有以下特征：

- `nodeType`值为8
- `nodeName`值为`"#comment"`
- `nodeValue`值为注释内容
- `parentNode`值为Document或Element对象
- 不支持子节点

Comment类型与Text类型继承同一个基类（characterData），因此拥有除了`splitText()`以外Text节点所有的字符串操作方法

通过`document.createComment()`方法创建注释节点

```js
let comment = document.createComment('A comment')
```

### DocumentType类型

DocumentType类型的节点包含文档的文档类型，具有以下特征：

- `nodeType`为10
- `nodeName`值为文档类型的名称
- `nodeValue`值为null
- `parentNode`值为Document对象
- 不支持子节点

DocumentType对象不支持动态创建，只能在解析文档时创建。

DocumentType对象保存在`document.doctype`属性中

### DocumentFragment类型

DOM将文档片段定义为"轻量级"文档，具有以下特征：

- `nodeType`为11
- `nodeName`值为`"#document-fragment"`
- `nodeValue`值为null
- `parentNode`值为null

不能直接把文档片段添加到文档。文档片段的作用是充当其他要被添加到文档的节点的仓库。

`document.createDocumentFragment()`用来创建文档片段

文档片段从Node类型继承了所有DOM操作方法。如果文档中的一个节点被添加到文档片段，则该节点会从文档树中移除。可以通过`appendChild()`和`insertBefore()`将文档片段的内容通过传参添加到文档中。文档片段本身不会被添加到文档树中。

### Attr类型

元素属性在DOM中通过`Attr`类型表示。`Attr`节点特征：

- `nodeType`为2
- `nodeName`值为属性名
- `nodeValue`值为属性值
- `parentNode`值为null

`Attr`对象上有3个属性：name、value和specified。name值为属性名，value值为属性值，specified值是表示使用的是默认值还是被指定值的布尔值

`document.createAttribute(属性名)`用来创建新的Attr节点，参数是属性名

`setAttributeNode(Attr)`将新属性添加到元素上

`getAttributeNode(属性名)`返回属性名对应的Attr节点

```js
let attr = document.createAttribute('align')
attr.value = 'right'
article.setAttributeNode(attr)
article.getAttributeNode('align').value // right
```

## DOM编程

### 动态脚本

有两种方式可以动态为网页添加脚本：引入外部文件和直接插入源代码

**动态引入外部文件**

```js
function loadScript(url){
	let script = document.createElement('script')
	script.src = url
	document.body.appendChild(script)
}

loadScript('client.js')
```

动态插入Javascript**源码**

```js
function loadScriptString(code){
	let script = document.createElement('script')
	script.type = "text/javascript"
	try{
		script.appendChild(document.createTextNode(code))
	}catch(e){
		script.text = code // IE不允许常规DOM访问script子节点，但script元素上有text属性可以用来添加js代码
	}
    document.body.appendChild(script)
}

loadScriptString("function sayHi(){alert('hi');}")
```

通过`innerHTML`创建的script元素永不执

### 动态样式

css样式在HTML中可以通过两个元素加载：link和style

**link元素**

```js
function loadStyles(url){
	let link = document.createElement('link')
	link.rel = 'stylesheet'
	link.type = 'text/css'
	link.href = url
	let head = document.getElementByTagName('head')[0]
	head.appendChild(link)
}
loadStyles('style.css')
```

**style元素**

```js
function loadStyleString(css){
	let style = document.createElement('style')
	style.type = 'text/css'
    try{
    	style.appendChild(document.createTextNode(css))
    }catch(e){
    	style.styleSheet.cssText = css // IE不能给style添加子节点，可通过访问style节点的styleSheet属性的cssText属性
    }
    let head = document.getElementsByTagName('head')[0]
    head.appendChild(style)
}
```

